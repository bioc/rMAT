%\VignetteIndexEntry{The rMAT users guide}
%\VignetteDepends{rMAT}
%\VignetteKeywords{Preprocessing, Affymetrix}
%\VignettePackage{rMAT}
\documentclass[11pt]{article}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color, pdfcolmk}
\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

\author{Charles Cheunga\footnote{cykc@interchange.ubc.ca} and Raphael
  Gottardo\footnote{raphael.gottardo@ircm.qc.ca} and Arnaud Droit\footnote{arnaud.droit@ircm.qc.ca}}

\usepackage{Sweave}
\begin{document}
\title{Model Based Analysis of Tiling Arrays\\ The rMAT package.}
\maketitle



\textnormal {\normalfont}
A step-by-step guide in the analysis of tiling array data using the rMAT package in R

\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage


\part{Licensing}

Under the Artistic license 2.0, you are free to use and redistribute this software. However, we ask you to cite the following paper if you use this software for publication. 

\begin{itemize}
\item[]W. E. Johnson, Li, W., Meyer, C. A., Gottardo, R., Carroll, J. S., Brown, M., and Liu, X. S. (2006). Model-based analysis of tiling-arrays for ChIP-chip. PNAS 103:12457-12462.
\end{itemize}

\part{Introduction}
	In our guide, we include examples of code that we hope will help you when using the rMAT package. The examples are kept at the basic level for ease of understanding. Some of the options in the functions have been set by default. To learn more about the exact parameters and usage of each function, you may type \verb@help(FUNCTION_NAME)@ of the function of interest in R after the rMAT package is loaded.
\newline

The probe sequence information of an Affymetrix tiling array is stored in the .BPMAP file, while the corresponding expression values (intensity signals) of each experiment is stored separately in each .CEL file. The BPMAP file contains different sequences that describe different contents in the array. For instance, the first sequence may contain probes from chromosome 1 while the second sequence may contain probes from chromosome 2. Each probe would include information such as its Perfect Match base pair sequence (ie. AGCTTCGAAGCTTCGAAGCTTCGAG), location on chromosome, X and Y coordinates, etc. The CEL file does not know anything about the design of the array; it is just a file with  columns such as X coordinate, Y coordinate, expression value, and other auxiliary columns. For each array experiment (ie. mock, treated with reagent X, treated with reagent Y), we have one CEL file. These two type of files are stored in a binary format and require a parser (reader) to read its content meaningfully. 
\newline
	The common goal in analyzing this type of data is to find activities (DNA-protein interaction, transcription, etc) in specific chromosomal regions. This package focus on detecting DNA-protein interactions from ChIP-chip experiments. Though, many of the functions are more general than that. The steps in analyzing the tiling array data are as follows.


\part{Loading the rMAT Package}
To load the rMAT package in R, we type 


\begin{Schunk}
\begin{Sinput}
> library(rMAT)
\end{Sinput}
\end{Schunk}

\part{Loading in the data}
The next step in a typical analysis is to load in data from Affymetrix CEL files. 
The data used in this example are available in this package in inst/doc folder. \newline 
In this documentation, the path for the data are :  /rMAT/inst/doc folder. 

\part{Reading BPMAP and CEL files}

\subsection*{Reading the design of tiling array}

	The first step in analyzing tiling array data is to understand the content of the data. To understand the design, we would explore the header section of the BPMAP file using the function ReadBPMAPAllSeqHeader. ReadBPMAPAllSequence takes in the filename of the BPMAP file as an argument. The filename is formatted as a string literal (characters) in unix path format and stored in the variable BPMAPFile, which is then used by \textbf{ReadBPMAPAllSeqHeader} to specify which BPMAP file to read. 

\begin{Schunk}
\begin{Sinput}
> pwd <- ""
> path <- system.file("doc/Sc03b_MR_v04_10000.bpmap", package = "rMAT")
> bpmapFile = paste(pwd, path, sep = "")
> seqHeader <- ReadBPMAPAllSeqHeader(bpmapFile)
\end{Sinput}
\end{Schunk}

\subsection*{Specifying the filenames}
From the above header content, the information we want to obtain is the direct mapping from sequence number to chromosome number.
Sequence number is stored in the seqNum column while chromosome number can be read from the Name column, which describes the content of the \verb@sequence@.
\newline
	We would like to read the BPMAP and CEL files and merge them by X and Y coordinate so information such as probe sequence and location along the chromosome would pair up with the corresponding expression value. 
\newline
	We have already specified the location of the BPMAP file in BPMAPFile variable, so now let's specify the location of the CEL files. Because BPMAPCelParser allows us to parse multiple CEL files simultaneously, we can store the location of multiple files in a vector using \verb@c()@
 each separate by \verb@","@
. 
\begin{Schunk}
\begin{Sinput}
> pathCEL <- system.file("doc/Swr1WTIP_Short.CEL", package = "rMAT")
> arrayFile <- paste(pwd, c(pathCEL), sep = "")
\end{Sinput}
\end{Schunk}

\subsection*{Calling BPMAPCelParser}
We are now ready to call the BPMAPCelParser. 
\\
 
\begin{Schunk}
\begin{Sinput}
> ScSet <- BPMAPCelParser(bpmapFile, arrayFile, verbose = FALSE, 
+     groupName = "Sc")
\end{Sinput}
\end{Schunk}

groupeName corresponding to the genome name used. In this example, we specefied saccharomyces cerevisiae genome (Sc)


This function returns an object of class tilingSet containing all necessary information: probe sequences, genomic positions, chromosomes as well as the probe intensities. 

The list of vectors of the merged data are now stored in ScSet.
Let's explore the (partial) content of ScSet.

\begin{Schunk}
\begin{Sinput}
> summary(ScSet)
\end{Sinput}
\begin{Soutput}
   Genome interrogated:  Sc03b_MR_v04_10000  
   Chromosome(s) interrogated: 1 
   Sample name(s):  Swr1WTIP_Short  
   The total number of probes is:  10000  
   Preprocessing Information 
     - Transformation: log 
     - Normalization: none 
\end{Soutput}
\end{Schunk}

We are now ready to normalize the raw data. Normalization is a procedure to transform raw data into the so-called normalized expression data so expression values from different tiling arrays can be compared. 

\part{Normalization}
The NormalizeProbes function allows users to normalize expression values of different experiments with one command, as long as all those experiments use the same BPMAP tiling design file. We can load these raw expression values in batch using \verb@cbind()@. NormalizeProbes also requires users to specify the sequence vector. In this case, it is a vector of characters containing the 25 base pair sequence of each probe.  (Right now, Normalization works for reading 25mer only.)

For a complete list of parameters for NormalizeProbes, please refer to 
\newline
\verb@help(NormalizeProbes)@.	
	We are now ready to run the command.

\begin{Schunk}
\begin{Sinput}
> ScSetNorm <- NormalizeProbes(ScSet, method = "MAT", robust = FALSE, 
+     all = FALSE, standard = TRUE, verbose = FALSE)
\end{Sinput}
\end{Schunk}

The user can choose from "MAT", or "PairBinned" normalization method. byeThe Pair option also takes into account of the interaction between adjacent pairs along the probe as covariates for linear regression.

The output in this example is saved in \verb@ScSetNorm@. 

Let's explore the (partial) content of ScSetNorm.

\begin{Schunk}
\begin{Sinput}
> summary(ScSetNorm)
\end{Sinput}
\begin{Soutput}
   Genome interrogated:  Sc03b_MR_v04_10000  
   Chromosome(s) interrogated: 1 
   Sample name(s):  Swr1WTIP_Short  
   The total number of probes is:  10000  
   Preprocessing Information 
     - Transformation: log 
     - Normalization: MAT standardized 
\end{Soutput}
\end{Schunk}


\part{Finding the Enriched Regions}
After normalization, we are ready to find enriched regions.  We can adjust the threshold for detection of enriched regions. A higher threshold provides a stricter criterion and thus less regions are expected. A higher threshold value also means that the enriched regions would be shorter on average. Please note that the threshold for MATScore with control and without control can be very different because with control the expression values from the Immunoprecipated data is subtracted from the that of the Control. The generated list of MAT enriched regions will be written to a file defined by parameter output if it is specified. For more details about the overall procedure please refer to the paper cited above.

For a comprehensive list of parameters you can adjust in MATScore, please refer to \verb@help(MATScore)@.
Another note is that if FDR is used, threshold should be set in the range between 0 and 1.

\begin{Schunk}
\begin{Sinput}
> RD <- computeMATScore(ScSetNorm, cName = NULL, dMax = 600, verbose = TRUE)
\end{Sinput}
\begin{Soutput}
** Finished processing  10000  probes on  1  arrays **
\end{Soutput}
\begin{Sinput}
> Enrich <- callEnrichedRegions(RD, dMax = 600, dMerge = 300, nProbesMin = 8, 
+     method = "score", threshold = 1, verbose = FALSE)
\end{Sinput}
\end{Schunk}


\section{Creating an annotation graphic}
rMAT results can benefit from integreated visualisation of the genomic information. We have decided to use the rtrackalayer  or GenomeGraphs package \href{http://www.bioconductor.org/packages/2.2/bioc/html/GenomeGraphs.html}{GenomeGraphs package}.This last package uses the biomaRt package to deliver queries to Ensembl e.g. gene/transcript structures to viewports of the grid package, resulting in genomic information plotted together with your data. 

To load the GenomeGraphs package in R, we type 
\begin{Schunk}
\begin{Sinput}
> library(GenomeGraphs)
> library(rtracklayer)